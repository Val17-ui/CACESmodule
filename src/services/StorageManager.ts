// src/services/StorageManager.ts
import { QuestionWithId, Omit } from '../types'; // Importer Omit et les types nécessaires depuis ../types

// Re-export QuestionWithId as StoredQuestion for clarity
export type StoredQuestion = QuestionWithId;

// Vérification que dbAPI est disponible (important pour le contexte de rendu)
if (typeof window === 'undefined' || !window.dbAPI) {
  // Si window ou window.dbAPI n'est pas défini, cela signifie que nous ne sommes pas dans un environnement de rendu Electron configuré correctement.
  // Cela peut arriver lors de tests unitaires côté Node sans mock de l'API Electron, ou si le preload n'a pas fonctionné.
  // Pour les tests unitaires purs de StorageManager, il faudrait mocker window.dbAPI.
  // Pour l'exécution dans l'application, cela indiquerait un problème de configuration.
  console.warn(
    'window.dbAPI is not available. StorageManager DB calls will fail. ' +
    'Ensure this code runs in an Electron renderer context with the preload script correctly configured.'
  );
}


export const StorageManager = {
  // Les réexportations directes des fonctions de '../db.ts' sont supprimées.
  // Toutes les interactions DB se feront via window.dbAPI.

  /**
   * Adds a new question to the database.
   * The 'id' field should be omitted as it's auto-generated by Dexie.
   * @param questionData - The question data without the 'id'.
   * @returns The ID of the newly added question, or undefined if an error occurs.
   */
  async addQuestion(questionData: Omit<StoredQuestion, 'id'>): Promise<number | undefined> {
    if (!window.dbAPI?.addQuestion) throw new Error("dbAPI.addQuestion is not available.");
    try {
      const id = await window.dbAPI.addQuestion(questionData);
      return id;
    } catch (error) {
      console.error("StorageManager: Error adding question via IPC", error);
      throw error; // Re-throw to allow UI to handle it
    }
  },

  /**
   * Retrieves all questions from the database.
   * @returns An array of StoredQuestion objects.
   */
  async getAllQuestions(): Promise<StoredQuestion[]> {
    if (!window.dbAPI?.getAllQuestions) throw new Error("dbAPI.getAllQuestions is not available.");
    try {
      const questions = await window.dbAPI.getAllQuestions();
      return questions;
    } catch (error) {
      console.error("StorageManager: Error getting all questions via IPC", error);
      throw error;
    }
  },

  /**
   * Retrieves a specific question by its ID.
   * @param id - The ID of the question to retrieve.
   * @returns The StoredQuestion object if found, otherwise undefined.
   */
  async getQuestionById(id: number): Promise<StoredQuestion | undefined> {
    if (!window.dbAPI?.getQuestionById) throw new Error("dbAPI.getQuestionById is not available.");
    try {
      const question = await window.dbAPI.getQuestionById(id);
      return question;
    } catch (error) {
      console.error(`StorageManager: Error getting question with id ${id} via IPC`, error);
      throw error;
    }
  },

  /**
   * Updates an existing question in the database.
   * @param id - The ID of the question to update.
   * @param updates - An object containing the fields to update.
   * @returns The number of updated records (0 or 1), or undefined if an error occurs.
   */
  async updateQuestion(id: number, updates: Partial<Omit<StoredQuestion, 'id'>>): Promise<number | undefined> {
    if (!window.dbAPI?.updateQuestion) throw new Error("dbAPI.updateQuestion is not available.");
    try {
      // Omit 'id' from updates object for the IPC call, as the main process handler expects this.
      const { id: _, ...restUpdates } = updates as any; // Cast to any if 'id' might not be in updates
      const numUpdated = await window.dbAPI.updateQuestion(id, restUpdates);
      return numUpdated;
    } catch (error) {
      console.error(`StorageManager: Error updating question with id ${id} via IPC`, error);
      throw error;
    }
  },

  /**
   * Deletes a question from the database.
   * @param id - The ID of the question to delete.
   * @returns A promise that resolves when the deletion is complete, or rejects on error.
   */
  async deleteQuestion(id: number): Promise<void> {
    if (!window.dbAPI?.deleteQuestion) throw new Error("dbAPI.deleteQuestion is not available.");
    try {
      await window.dbAPI.deleteQuestion(id);
    } catch (error) {
      console.error(`StorageManager: Error deleting question with id ${id} via IPC`, error);
      throw error;
    }
  },

  // Methods related to 'Questionnaire' entity have been removed:
  // - addQuestionnaire
  // - getAllQuestionnaires
  // - getQuestionnaireById
  // - updateQuestionnaire
  // - deleteQuestionnaire

  /**
   * Retrieves all unique base themes for a given referential.
   * e.g., for 'securite_A', 'securite_B', 'technique_A', it would return ['securite', 'technique'].
   * @param referential - The CACES referential.
   * @returns A promise that resolves to an array of unique base theme names.
   */
  // getAllBaseThemesForReferential has been removed.
  // Use StorageManager.db.getThemesByReferentialId(referentialId: number) instead.
  // Example:
  // const referential = await StorageManager.db.getReferentialByCode("R489");
  // if (referential && referential.id) {
  //   const themes = await StorageManager.db.getThemesByReferentialId(referential.id);
  //   // themes will be an array of Theme objects
  // }

  // getAllBlockIdentifiersForTheme has been removed.
  // Use StorageManager.db.getBlocsByThemeId(themeId: number) instead.
  // Example:
  // const theme = await StorageManager.db.getThemeByCodeAndReferentialId("R489PR", referentialId);
  // if (theme && theme.id) {
  //   const blocs = await StorageManager.db.getBlocsByThemeId(theme.id);
  //   // blocs will be an array of Bloc objects
  // }
  // >>> The above comments are now obsolete as StorageManager.db (direct db access) is removed.
  // >>> If these aggregate functions are needed, they should be rebuilt using window.dbAPI calls.

  /**
   * Retrieves all questions for a specific blocId.
   * @param blocId - The ID of the bloc.
   * @returns A promise that resolves to an array of StoredQuestion objects.
   */
  async getQuestionsForBloc(blocId: number): Promise<StoredQuestion[]> {
    if (!window.dbAPI?.getQuestionsByBlocId) throw new Error("dbAPI.getQuestionsByBlocId is not available.");
    try {
      const questions = await window.dbAPI.getQuestionsByBlocId(blocId);
      return questions;
    } catch (error) {
      console.error(`StorageManager: Error getting questions for blocId ${blocId} via IPC`, error);
      throw error;
    }
  }
};

// Example usage (optional, for testing or demonstration within this file):
/*
async function testStorageManager() {
  console.log("Testing StorageManager...");

  // Test addQuestion
  const newQuestionData: Omit<StoredQuestion, 'id'> = {
    text: "What is 2+2?",
    type: "multiple-choice",
    options: ["3", "4", "5"],
    correctAnswer: "4",
    isEliminatory: false,
    referential: "R489", // Assuming ReferentialType allows this
    theme: "Calculs",    // Assuming QuestionTheme allows this
    createdAt: new Date().toISOString(),
  };
  const addedId = await StorageManager.addQuestion(newQuestionData);
  console.log("Added question with ID:", addedId);

  if (addedId) {
    // Test getQuestionById
    const fetchedQuestion = await StorageManager.getQuestionById(addedId);
    console.log("Fetched question by ID:", fetchedQuestion);

    // Test updateQuestion
    const updates: Partial<StoredQuestion> = { text: "What is two plus two?" };
    const updatedCount = await StorageManager.updateQuestion(addedId, updates);
    console.log("Updated question, count:", updatedCount);
    const updatedQuestion = await StorageManager.getQuestionById(addedId);
    console.log("Fetched updated question:", updatedQuestion);


    // Test getAllQuestions
    // const allQuestions = await StorageManager.getAllQuestions();
    // console.log("All questions:", allQuestions);


    // Test deleteQuestion
    // await StorageManager.deleteQuestion(addedId);
    // console.log("Deleted question with ID:", addedId);
    // const deletedQuestion = await StorageManager.getQuestionById(addedId);
    // console.log("Attempt to fetch deleted question:", deletedQuestion); // Should be undefined
  }

   const allQuestions = await StorageManager.getAllQuestions();
   console.log("All questions at end:", allQuestions);
}

// testStorageManager(); // Uncomment to run test
*/
