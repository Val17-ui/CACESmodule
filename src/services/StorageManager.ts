// src/services/StorageManager.ts
import {
  db,
  // QuestionWithId, // Retiré d'ici
  addReferentiel, // addReferential -> addReferentiel
  getAllReferentiels,
  getReferentielById, // getReferentialByCode -> getReferentielById (ou créer getReferentialByCode)
  addTheme,
  getAllThemes,
  getThemesByReferentielId,
  getThemeByCodeAndReferentialId, // Décommenté et importé
  addBloc,
  getAllBlocs,
  getBlocsByThemeId,
  getBlocByCodeAndThemeId, // Décommenté et importé
  // Imports spécifiques pour les méthodes de StorageManager ci-dessous
  addQuestion as dbAddQuestion,
  getAllQuestions as dbGetAllQuestions,
  getQuestionById as dbGetQuestionById,
  updateQuestion as dbUpdateQuestion,
  deleteQuestion as dbDeleteQuestion,
  getQuestionsByBlocId as dbGetQuestionsByBlocId,
  QuestionData as DBQuestionData // Type pour le cast
} from '../db';
import { QuestionWithId } from '../types'; // QuestionWithId importé d'ici
// CACESReferential might be unused now. Referential, Theme, Bloc types are likely still needed if StoredQuestion or other types here reference them.
// For now, let's keep Referential, Theme, Bloc types from ../types if they are implicitly used by QuestionWithId or other function signatures.
// import { CACESReferential, Referential, Theme, Bloc } from '../types';
// CACESReferential removed from imports as it's not directly used by StorageManager methods anymore.

// Re-export QuestionWithId as StoredQuestion for clarity within this module and for consumers
// StoredQuestion now reflects the new structure from db.ts (with blocId, without referential/theme)
export type StoredQuestion = QuestionWithId;
// StoredQuestionnaire type removed

export const StorageManager = {
  // Expose db functions for referentiels, themes, blocs directly by re-exporting them.
  // This makes them available under the StorageManager namespace for components that already use it.
  // Alternatively, components could import these directly from '../db.ts'.
  addReferentiel, // Corrigé
  getAllReferentiels,
  getReferentielById, // Corrigé
  addTheme,
  getAllThemes,
  getThemesByReferentielId, // Corrigé
  getThemeByCodeAndReferentialId, // Assuré qu'il est bien là
  addBloc,
  getAllBlocs,
  getBlocsByThemeId, // Assuré qu'il est bien là
  getBlocByCodeAndThemeId, // Assuré qu'il est bien là

  /**
   * Adds a new question to the database.
   * The 'id' field should be omitted as it's auto-generated by Dexie.
   * @param questionData - The question data without the 'id'.
   * @returns The ID of the newly added question, or undefined if an error occurs.
   */
  async addQuestion(questionData: Omit<StoredQuestion, 'id'>): Promise<number | undefined> {
    try {
      let dbCompatibleQuestionData: Partial<Omit<DBQuestionData, 'id'>> = { ...questionData } as any;

      if (questionData.image && questionData.image instanceof Blob) {
        dbCompatibleQuestionData.image = Buffer.from(await questionData.image.arrayBuffer());
      } else if (questionData.image === null) {
        dbCompatibleQuestionData.image = null;
      } else if (questionData.image !== undefined) {
        // If it's already a Buffer or some other non-Blob format, this might indicate an issue or prior conversion.
        // For safety, if it's not explicitly Blob or null, we might want to log or handle.
        // However, StoredQuestion type says Blob | null, so this path shouldn't be common.
        console.warn("StorageManager.addQuestion: questionData.image was neither Blob nor null. Type:", typeof questionData.image);
        // Assuming it might be an ArrayBuffer from IPC, try to convert. If not, it might fail at dbAddQuestion.
        if (questionData.image instanceof ArrayBuffer) {
            dbCompatibleQuestionData.image = Buffer.from(questionData.image);
        } else if (!Buffer.isBuffer(questionData.image)) {
             // If it's not a buffer already, and not ArrayBuffer, set to null to avoid DB error for incompatible type.
            dbCompatibleQuestionData.image = undefined; // Or null, depending on how dbAddQuestion handles undefined
        }
      }

      // Ensure blocId is present as it's mandatory in DBQuestionData (and StoredQuestion)
      if (typeof dbCompatibleQuestionData.blocId !== 'number') {
        // Throw error or handle as per application logic for missing blocId
        console.error("StorageManager.addQuestion: blocId is missing or not a number.", questionData);
        throw new Error("blocId is required to add a question.");
      }

      const newId = await dbAddQuestion(dbCompatibleQuestionData);
      return newId;
    } catch (error) {
      console.error("StorageManager: Error adding question", error);
      return undefined;
    }
  },

  /**
   * Retrieves all questions from the database.
   * @returns An array of StoredQuestion objects.
   */
  async getAllQuestions(): Promise<StoredQuestion[]> {
    try {
      const questions = await dbGetAllQuestions(); // Utiliser l'alias
      return questions as StoredQuestion[];
    } catch (error) {
      console.error("StorageManager: Error getting all questions", error);
      return [];
    }
  },

  /**
   * Retrieves a specific question by its ID.
   * @param id - The ID of the question to retrieve.
   * @returns The StoredQuestion object if found, otherwise undefined.
   */
  async getQuestionById(id: number): Promise<StoredQuestion | undefined> {
    try {
      const question = await dbGetQuestionById(id); // Utiliser l'alias
      return question as StoredQuestion | undefined;
    } catch (error) {
      console.error(`StorageManager: Error getting question with id ${id}`, error);
      return undefined;
    }
  },

  /**
   * Updates an existing question in the database.
   * @param id - The ID of the question to update.
   * @param updates - An object containing the fields to update.
   * @returns The number of updated records (0 or 1), or undefined if an error occurs.
   */
  async updateQuestion(id: number, updates: Partial<StoredQuestion>): Promise<number | undefined> {
    try {
      let dbCompatibleUpdates: Partial<DBQuestionData> = { ...updates } as any;

      if (updates.image && updates.image instanceof Blob) {
        dbCompatibleUpdates.image = Buffer.from(await updates.image.arrayBuffer());
      } else if (updates.image === null) {
        dbCompatibleUpdates.image = null;
      } else if (updates.image !== undefined) {
        console.warn("StorageManager.updateQuestion: updates.image was neither Blob nor null. Type:", typeof updates.image);
        if (updates.image instanceof ArrayBuffer) {
            dbCompatibleUpdates.image = Buffer.from(updates.image);
        } else if (!Buffer.isBuffer(updates.image)) {
            dbCompatibleUpdates.image = undefined;
        }
      }

      // If blocId is part of updates, ensure it's a number
      if (updates.blocId !== undefined && typeof updates.blocId !== 'number') {
        console.error("StorageManager.updateQuestion: updates.blocId is not a number.", updates);
        throw new Error("If blocId is being updated, it must be a number.");
      }

      await dbUpdateQuestion(id, dbCompatibleUpdates);
      return 1; // Assuming 1 means success, though dbUpdateQuestion is void
    } catch (error) {
      console.error(`StorageManager: Error updating question with id ${id}`, error);
      return undefined;
    }
  },

  /**
   * Deletes a question from the database.
   * @param id - The ID of the question to delete.
   * @returns A promise that resolves when the deletion is complete, or rejects on error.
   */
  async deleteQuestion(id: number): Promise<void> {
    try {
      await dbDeleteQuestion(id); // Utiliser l'alias
    } catch (error) {
      console.error(`StorageManager: Error deleting question with id ${id}`, error);
    }
  },

  // Methods related to 'Questionnaire' entity have been removed:
  // - addQuestionnaire
  // - getAllQuestionnaires
  // - getQuestionnaireById
  // - updateQuestionnaire
  // - deleteQuestionnaire

  /**
   * Retrieves all unique base themes for a given referential.
   * e.g., for 'securite_A', 'securite_B', 'technique_A', it would return ['securite', 'technique'].
   * @param referential - The CACES referential.
   * @returns A promise that resolves to an array of unique base theme names.
   */
  // getAllBaseThemesForReferential has been removed.
  // Use StorageManager.db.getThemesByReferentialId(referentialId: number) instead.
  // Example:
  // const referential = await StorageManager.db.getReferentialByCode("R489");
  // if (referential && referential.id) {
  //   const themes = await StorageManager.db.getThemesByReferentialId(referential.id);
  //   // themes will be an array of Theme objects
  // }

  // getAllBlockIdentifiersForTheme has been removed.
  // Use StorageManager.db.getBlocsByThemeId(themeId: number) instead.
  // Example:
  // const theme = await StorageManager.db.getThemeByCodeAndReferentialId("R489PR", referentialId);
  // if (theme && theme.id) {
  //   const blocs = await StorageManager.db.getBlocsByThemeId(theme.id);
  //   // blocs will be an array of Bloc objects
  // }

  /**
   * Retrieves all questions for a specific blocId.
   * @param blocId - The ID of the bloc.
   * @returns A promise that resolves to an array of StoredQuestion objects.
   */
  async getQuestionsForBloc(blocId: number): Promise<StoredQuestion[]> {
    try {
      const questions = await dbGetQuestionsByBlocId(blocId); // Utiliser l'alias
      return questions as StoredQuestion[];
    } catch (error) {
      console.error(`StorageManager: Error getting questions for blocId ${blocId}`, error);
      return [];
    }
  }
};

// Example usage (optional, for testing or demonstration within this file):
/*
async function testStorageManager() {
  console.log("Testing StorageManager...");

  // Test addQuestion
  const newQuestionData: Omit<StoredQuestion, 'id'> = {
    text: "What is 2+2?",
    type: "multiple-choice",
    options: ["3", "4", "5"],
    correctAnswer: "4",
    isEliminatory: false,
    referential: "R489", // Assuming ReferentialType allows this
    theme: "Calculs",    // Assuming QuestionTheme allows this
    createdAt: new Date().toISOString(),
  };
  const addedId = await StorageManager.addQuestion(newQuestionData);
  console.log("Added question with ID:", addedId);

  if (addedId) {
    // Test getQuestionById
    const fetchedQuestion = await StorageManager.getQuestionById(addedId);
    console.log("Fetched question by ID:", fetchedQuestion);

    // Test updateQuestion
    const updates: Partial<StoredQuestion> = { text: "What is two plus two?" };
    const updatedCount = await StorageManager.updateQuestion(addedId, updates);
    console.log("Updated question, count:", updatedCount);
    const updatedQuestion = await StorageManager.getQuestionById(addedId);
    console.log("Fetched updated question:", updatedQuestion);


    // Test getAllQuestions
    // const allQuestions = await StorageManager.getAllQuestions();
    // console.log("All questions:", allQuestions);


    // Test deleteQuestion
    // await StorageManager.deleteQuestion(addedId);
    // console.log("Deleted question with ID:", addedId);
    // const deletedQuestion = await StorageManager.getQuestionById(addedId);
    // console.log("Attempt to fetch deleted question:", deletedQuestion); // Should be undefined
  }

   const allQuestions = await StorageManager.getAllQuestions();
   console.log("All questions at end:", allQuestions);
}

// testStorageManager(); // Uncomment to run test
*/
